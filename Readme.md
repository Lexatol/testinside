# Тестовое задание от компании Inside

    1.	В БД создать пару sql табличек со связями (foreign keys)

    2.	Сделать HTTP POST эндпоинт, который получает данные в json вида:
    {
        		name: "имя отправителя"
        		password: "пароль" 
    }
    3.	этот эндпоинт проверяет пароль по БД и создает jwt токен (срок действия токена 
    и алгоритм подписи не принципиален, для генерации и работе с токеном можно использовать готовую библиотечку)
    в токен записывает данные: name: "имя отправителя" и отправляет токен в ответ, тоже json вида:
    {   
   	    	 token: "тут сгенерированный токен" 
    }
    4.	Сервер слушает и отвечает в какой-нибудь эндпоинт, в него на вход поступают данные в формате json:
    Сообщения клиента-пользователя:
    {
   	    	 name:       "имя отправителя",
  	    	 message:    "текст сообщение"
    }
    В заголовках указан Bearer токен, полученный из эндпоинта выше (между Bearer и полученным 
    токеном должно быть нижнее подчеркивание).
    Проверить токен, в случае успешной проверки токена, полученное сообщение сохранить в БД.
    5.	Если пришло сообщение вида:
    {
 	    	   name:       "имя отправителя",
    	       message:    "history 10"
    }
    проверить токен, в случае успешной проверки токена отправить отправителю 10 последних сообщений из БД
    6.	Добавить описание и инструкцию по запуску и комментарии в коде, если изменяете формат сообщений, 
    то подробное описание ендпоинтов и их полей.
    7.	Завернуть все компоненты в докер, покрыть код тестами.
    8.	Проект необходимо выкладывать на github и docker hub. Обязательно наличие readme-файла. 
    9.	Составить запросы (curl) через терминал для проверки работоспособности вашей программы 
    (приложить файл с запросами).

# Описание проекта
    Для разработки приложения был использован следующий стэк: Java 11, Spring Boot, Spring Security, JWT, 
    FlyWay, H2database, PostgreSQL, Lombok. 
    Для проведения тестирования: Junit 5, Mockito
    Приложение упаковано в docker сontainer и разворачивается с помощью docker-compose.
    Файлы docker и docker-compose приложены к проекту.

# В приложении реализован функционал согласно технического задания:
    - авторизация пользователей с помощью jwt-token. В приложении не реализован функционал по регистрации пользователей, 
    так как это не было предусмотрено технических заданием.
    - сохранение сообщений от авторизованных пользователей
    - выдача последних десяти сохраненных сообщений. В приложении предусмотрен функционал для расширения данной 
    возможности (выдача заданного количества последних сообщений)
    - расширен функционал сущности message и добавлено время создания
    - контейнер проекта размещен в docker hub по адресу: https://hub.docker.com/r/lexp00/testinside
    - код проекта размещен в github: https://github.com/Lexatol/testinside
    - весь проект оттестирован с помощью Junit 5 и Mockito


# Реализация проекта

## База хранения данных:
    Для работы приложения была использована база PostgreSQL, для тестирования H2database
    Как в основной, так и в базе для тестирования предварительно занесены данные о пользователях:
    Login: Petya, password: 100
    Login: Vasya, password: 100
    Пароли в базе хранятся в зашифрованном виде посредством Bcrypt Password

## Развертывание приложения:
    Для локальной установки проекта вам нужен установленный docker. 
    Необходимо из корневого каталога проекта “testinside”  скачать файл docker-compose.yml и 
    запустить его следующей командой:
        docker-compose up -d 
    Произойдет сборка контейнеров PostgreSQL и testinside из docker hub, после сборки контейнеры 
    запустятся автоматически.

## Тестирование работы приложения:
    Из корневого каталога проекта “testinside” скачать и импортировать в postman (либо другую платформу 
    для тестирования api) файл  Test inside.postman_collection.json
    
    В Postman необходимо пройти авторизацию и получить token запустив тест “Authorization”.
    В body вам будет выдан token, который вы будете использовать в дальнейшем при других запросах.

### Сохранение сообщения в базу данных:
    Для сохранения сообщения от авторизованного пользователя вам необходимо запустить тест “save massage”. 
    Для запуска теста необходимо первоначально в параметрах запроса во закладке “Headers” вручную создать новый ключ 
    со следующими параметрами:
    Key: Authorization, Value: "Bearer_" + "token". Token не содержит начала ключа "Bearer_" 
    поэтому вам необходимо его добавить самостоятельно.

    В закладку “Body” вам нужно добавить информацию, которую вы ходите отправить post запросом. 
    Добавление информации происходит в формате json. 
    Предварительно данные внесены для тестирования
    {
        "name": "Vasya",
      "description": "это вот реально последнее сообщение"
    }
    
    При отправке данного сообщения произойдет проверка token и при положительном исходе сохранения с
    ообщения в базу данных. В виде 
    {
           "name": "Vasya",
           "description": "это вот реально последнее сообщение",
           "createAt": "03-08-2022 19:31:06"
    }
    В исходные данные дополнительно добавлено поле createAt в сущность «сообщения», 
    которое несет в себе дату и время создания сообщения
    При несовпадении пользователя и его подписи будет выдано сообщение: You is not authorization

### Отправка пользователю 10 последних сообщений:

    Для выдачи десяти последних сообщений вам необходимо повторить ряд действий связанных с добавлением 
    ключа и значения token в тело Headers сообщения, а также отправить запрос во закладке Body 
    {
      "name": "Vasya",
     "description": "history 10"
    }   
    При несовпадении подписи и имени пользователя будет отправлено сообщение: You is not authorization

    В положительном исходе 
    Будет выдан массив из десяти сообщений отсортированных в порядке добавления в базу 
    [
        {
            "name": "Vasya",
            "description": "Какой я не постоянный, опять чего-нибудь добавить хочу",
            "createAt": "04-08-2022 06:18:08"
        },
        {
            "name": "Vasya",
            "description": "Я решил начать заново добавлять",
            "createAt": "04-08-2022 06:17:52"
        },
        {
            "name": "Vasya",
            "description": "Да нее, вот это последнее",
            "createAt": "04-08-2022 06:17:38"
        },
        {
            "name": "Vasya",
            "description": "это вот реально последнее сообщение, а может быть вот это",
            "createAt": "04-08-2022 06:17:28"
        },
        {
            "name": "Vasya",
            "description": "это вот реально последнее сообщение",
            "createAt": "04-08-2022 06:17:13"
        },
        {
            "name": "Vasya",
            "description": "message 6",
            "createAt": "02-08-2022 15:02:42"
        },
        {
            "name": "Vasya",
            "description": "message 7",
            "createAt": "02-08-2022 15:02:42"
        },
        {
            "name": "Vasya",
            "description": "message 8",
            "createAt": "02-08-2022 15:02:42"
        },
        {
            "name": "Vasya",
            "description": "message 9",
            "createAt": "02-08-2022 15:02:42"
        },
        {
            "name": "Vasya",
            "description": "message 10",
            "createAt": "02-08-2022 15:02:42"
        }
    ]

